<!DOCTYPE html>

<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mo's algorithm visualizer</title>

        <!-- favicon setting from: https://zenn.dev/pacchiy/articles/e4dcd7bd29d387 -->
        <link rel="icon" sizes="48x48" href="favicon.png" />
        <link rel="apple-touch-icon" href="favicon.png">

        <script src="canvas.js"></script>
        <script src="drawer.js"></script>
        <script src="query_generator.js"></script>
        <script src="mo.js"></script>
        <script src="input_validator.js"></script>
        <script src="main.js"></script>

        <!-- loading katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>

        <script src="katex_loader.js"></script>

    </head>

    <body>
        <h1>Mo's algorithm visualizer</h1>
        <canvas id="main_canvas" style="border: black 1px solid"></canvas>
        <div>
            <h2>Result</h2>
            <ul>
                <li>総クエリ数: <span id="result_query_count"></span></li>
                <li>巡回方法: <span id="result_method"></span></li>
                <li>総移動距離: <span id="result_distance_sum"></span></li>
            </ul>
        </div>

        <div style="display: flex;">
            <div style="flex: 40%;">
                <h2>クエリ生成機</h2>
                <div>
                    <label for="query_max_y">y軸最大値</label>
                    <input type="number" min="0", max="10000" value="500" id="query_max_y"></input>
                </div>
                <div>
                    <label for="query_max_x">x軸最大値</label>
                    <input type="number" min="0", max="10000" value="500" id="query_max_x"></input>
                </div>
                <div>
                    <label for="query_amount">クエリ数</label>
                    <input type="number" min="0", max="10000" value="100" id="query_amount"></input>
                </div>
                <div>
                    <button id="query_generate_button">クエリ点をランダム生成</button>
                </div>
            </div>
            <div style="flex: 40%;">
                <h2>クエリ入力</h2>
                <textarea id="query_input" style="height: 200pt; width: 20%"></textarea>
                <div>
                    <select id="sort_method">
                        <option>巡回順を選択してください</option>
                        <option>ソートなし</option>
                        <option>Mo (original)</option>
                        <option>Mo (hilbert curve)</option>
                    </select>
                </div>
                <div>
                    <button id="input_delete_button">クエリ入力を消去</button>
                    <button id="run_button">Run</button>
                </div>
            </div>
        </div>

        <hr />

        <h2>How to use</h2>
        <p>textareaに条件を満たすようにデータを入力しボタンを押すことで、それらに対するMo's algorithmの巡回順をcanvasに示します。条件を満たすデータをランダム生成する機能もあります。これを用いる場合、二軸の最大値を指定して「クエリ点をランダム生成」ボタンを押してください。データは以下のフォーマットに従う必要があります。</p>

        <pre>$Q$
$y _ 1$ $x _ 1$
$y _ 2$ $x _ 2$
$y _ 3$ $x _ 3$
$\dots$
$y _ Q$ $x _ Q$
        </pre>


        <h2>Mo's algorithmとは</h2>
        <p>次の条件を満たす区間クエリに適用できるアルゴリズム。</p>
        <ul>
            <li>クエリにより列が変化しない。</li>
            <li>現在見ている区間の伸縮がある程度高速に行える。</li>
            <li>「現在見ている区間」の情報からクエリに対する回答をある程度簡単に求める方法がある。</li>
        </ul>
        <p>区間クエリは$[l, r]$を二次元平面上の$(l, r)$に対応させることより、「ある区間から別の区間に変化させること」を「ある点からある点へとマンハッタン距離動くこと」と読み替えることができる。読み替えた問題における移動回数の和は区間の伸縮回数に対応するため、この値を小さくできればよい。この問題に対する厳密解は巡回セールスマン問題を解くこととほぼ等価になる。</p>
        <p>Mo's algorithmは移動距離をある程度小さな値に抑えるクエリ巡回順を与える。巡回セールスマン問題が$\mathcal{O}(N 2^N)$であるのに対して、Mo's algorithmは$\mathcal{O}(N \log N)$程度で行うことができる。</p>
        <p>ここではアルゴリズムのメインアイディアを紹介するにとどめる。詳細なアルゴリズムは以下を参照するとよい。</p>
        <ul>
            <li><a href="https://ei1333.hateblo.jp/entry/2017/09/11/211011">Mo's algorithm - ei1333の日記</a></li>
            <li><a href="https://nyaannyaan.github.io/library/misc/mo.hpp.html">Mo's algorithm - Nyaan's Library</a></li>
            <li><a href="https://codeforces.com/blog/entry/61203">An alternative sorting order for Mo's algorithm - Codeforces</a></li>
        </ul>
    </body>
</html>
